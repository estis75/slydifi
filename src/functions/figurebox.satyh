@require: list
@require: option

module FigureBox : sig

  type t

  val include-image : int?-> length -> string -> t
  val include-image-with-height : int?-> length -> string -> t

  val hconcat : t list -> t
  val vconcat : t list -> t
  val hmargin : length -> t -> t
  val vmargin : length -> t -> t
  val margin : length -> t -> t

  direct +fig-center : [t] block-cmd
  direct \fig-on-right : [t] inline-cmd
  direct +fig-on-right : [length?; t; block-text] block-cmd

end = struct

  type t =
    | Empty
    | PDF of length * string * int
    | JPEG of length * string
    | InlineBoxes of inline-boxes

  % FigureBox.t を inline-boxes 型に変換する．
  let to-inline-box fb =
    match fb with
    | Empty -> inline-nil
    | PDF(wid, pth, pg) -> use-image-by-width (load-pdf-image pth pg) wid
    | JPEG(wid, pth) -> use-image-by-width (load-image pth) wid
    | InlineBoxes(ib) -> ib

  % 画像読み込み {{{

  % ユーザが画像を読み込むときに使える統一的な関数．
  % 拡張子を判別してヴァリアントを変える．
  let include-image ?:pg wid pth =
    let pg = Option.from 1 pg in
    let sep-pat = regexp-of-string `\.` in
    let splitlst = (split-on-regexp sep-pat pth) in
    let (_, ext) = Option.from (0, ` `) (splitlst |> List.nth (List.length splitlst - 1)) in
    match ext with
    | `pdf`  -> PDF(wid, pth, pg)
    | `jpg`  -> JPEG(wid, pth)
    | `jpeg` -> JPEG(wid, pth)
    | `jpe`  -> JPEG(wid, pth)
    | `jfif` -> JPEG(wid, pth)
    | `jfi`  -> JPEG(wid, pth)
    | `jif`  -> JPEG(wid, pth)
    | _ ->
        let () = display-message (`Failed to include image: [` ^ pth ^ `]`) in
        Empty

  let include-image-with-height ?:pg ht pth =
    let pg = Option.from 1 pg in
    let ib = to-inline-box (include-image ?:pg 1pt pth) in
    let (_, ht-norm, _) = get-natural-metrics ib in
    let scale = ht /' ht-norm in
    include-image ?:pg (1pt *' scale) pth

  % }}}

  % FigureBox の変換 {{{

  let hconcat fblst =
    let iblst = fblst |> List.map to-inline-box in
    let ib = iblst |> List.fold-left (++) inline-nil in
    InlineBoxes(ib)

  let vconcat fblst =
    let iblst = fblst |> List.map to-inline-box in
    InlineBoxes(line-stack-bottom iblst)

  let hmargin len fb =
    let ib = (inline-skip len) ++ (to-inline-box fb) ++ (inline-skip len) in
    InlineBoxes(ib)

  let vmargin len fb =
    let vphantom = inline-graphics 0pt len 0pt (fun (_, _) -> []) in
    InlineBoxes(line-stack-bottom [vphantom; to-inline-box fb; vphantom])

  let margin len fb = hmargin len (vmargin len fb)

  % }}}

  let-block ctx +fig-center fb =
    let ib-fig = to-inline-box fb in
    line-break false false ctx (inline-fil ++ ib-fig ++ inline-fil)

  let-inline ctx \fig-on-right fb =
    let ib = to-inline-box fb in
    let (wid, ht, dp) = get-natural-metrics ib in
    inline-graphics 0pt 0pt 0pt (fun (x, y) -> [
      draw-text
        (x +' (get-text-width ctx) -' wid,
        y +' (ctx |> get-font-size) -' ht)
          ib
    ])

  let-block ctx +fig-on-right ?:margin fb bt =
    let margin = Option.from 20pt margin in
    let (ib-wid, _, _) = get-natural-metrics (to-inline-box fb) in
    let ib-fig = read-inline ctx {\fig-on-right(fb);} in
    let twid = get-text-width ctx in
    let wid = (get-text-width ctx) -' ib-wid -' margin in
    let ib-content = embed-block-top ctx wid (fun ctx -> read-block ctx bt) in
    line-break false false ctx (ib-fig ++ ib-content)


end
